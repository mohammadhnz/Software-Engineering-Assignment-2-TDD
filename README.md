![image](https://github.com/mohammadhnz/Software-Engineering-Assignment-2-TDD/assets/59181719/504fdd56-d91c-4ab7-9077-ea1eb35d4713)# Software-Engineering-Assignment-2-TDD
## TDD توسعه

<div dir="rtl"> 

برای اینکار ابتدا یک کلاس مستطیل و تعدادی تست پایه ساختیم.

![image](https://github.com/mohammadhnz/Software-Engineering-Assignment-2-TDD/assets/59181719/b94d7048-0155-4dfc-b766-ded26143bfff)
همانجور که مشاهده‌ میکنید این تست‌ها صرفا برای ساختن یک شی مستطیل و محاسبه مساحت آن ایجاد شده‌اند.
در ادامه دو تست اضافه برای اطمینان از عملکرد compute_area اضافه کردیم:

![image](https://github.com/mohammadhnz/Software-Engineering-Assignment-2-TDD/assets/59181719/a600173a-4cba-4d93-85ba-828cd821f73b)

در ادامه تست‌هایی برای آزمودن اعتبارسنجی هنگام ایجاد شی مستطیل اضافه کردیم که البته هرکدام فیل میشد آن را پاس میکردیم و میرفتیم سراغ بعدی:

![image](https://github.com/mohammadhnz/Software-Engineering-Assignment-2-TDD/assets/59181719/8873cdbd-b57d-4907-9b83-a468a08dc2d9)

تا اینجا شی مستطیل به شکل زیر درامد:

![image](https://github.com/mohammadhnz/Software-Engineering-Assignment-2-TDD/assets/59181719/f3c4e1f0-e21a-4558-b0f9-4e3028d09f6d)

پس از این دو تست برای set کردن عرض و طول مستطیل اضافه کردیم:

![image](https://github.com/mohammadhnz/Software-Engineering-Assignment-2-TDD/assets/59181719/54c4c5a1-2c8e-4b23-87a4-535647681621)

که برای پاس شدن آن ها کدهای زیر را اضافه کردیم:

![image](https://github.com/mohammadhnz/Software-Engineering-Assignment-2-TDD/assets/59181719/06f37fc0-229b-40ba-a991-741b3be41e6d)

در نهایت نوبت به پیاده سازی مربع رسید که برای پیاده‌سازی آن ابتدا دو تست نوشتیم:

![image](https://github.com/mohammadhnz/Software-Engineering-Assignment-2-TDD/assets/59181719/8c68bc11-d474-4b22-96f2-1c41c2572c43)

در نهایت مربع را از مستطیل ارث بری کردیم و پیاده سازی کردیم:

![image](https://github.com/mohammadhnz/Software-Engineering-Assignment-2-TDD/assets/59181719/d59bd6ec-2bfd-4f06-a63e-95822b45133b)

در نهایت یک ریفکتور میکنیم تا ارث بری اشتباه از بین رود.
![image](https://github.com/mohammadhnz/Software-Engineering-Assignment-2-TDD/assets/59181719/0604690b-e87c-44be-9da4-93092562fc7f)

![image](https://github.com/mohammadhnz/Software-Engineering-Assignment-2-TDD/assets/59181719/d0203cd4-3057-4f99-88ab-9c130e5b93ea)

در جواب پاسخ سوال اول که گفته‌اید هرکدام از اصول solid ار توضیح دهیم داریم:
اصل SRP به این معنیست که هر کلاس دقیقا یک دلیل برای تغییر داشته باشد. درواقع هدف از این اصل این هست که side effect های کمتری داشته باشیم تا با وقوع تغییر، اتفاقات ناخواسته کمتری بیافتد و نیاز به تغییرهای کمی باشد.
اصل OCP به این معنیست که کلاس نسبت به توسعه باز باشد ولی نسبت به تغییر بسته. درواقع به این معنی هست که در صورت نیاز بتوان کلاس را تغییر داد ولی نباید آن را تغییر داد.
اصل LSP میگوید که باید بتوان کلاس پدر را با کلاس فرزند جایگزین کرد بدون آنکه مشکلی در اجرای برنامه پیش بیاید. درواقع کلاس فرزند نباید کمتر از کلاس پدر امکانات داشته باشد.
اصل ISP بیان میکند که وقتی ارث بری شکل گرفته باید همه متد های کلاس پدر پیاده سازی و استفاده شده باشند. درواقع نباید موجودیت Minion از موجودت Tower ارث بری کند.
اصل DIP درواقع به این اشاره دارد که ماژول با سطح انتزاع بالاتر نیاز به ماژول به سطح انتزاع پایین تر نداشته باشد. 
سوال دوم: بیشتر در فاز طراحی و پیاده‌سازی نرم‌افزار به درد میخورد. ولی در همه مراحل میتوان از این اصول برای ایجاد نرم‌افزار بهتر استفاده کرد.
سوال سوم: خیر این دو روش تناقضی با هم ندارند. حتی در صورت توسعه محصول با روش TDD در نهایت برای باگ‌های احتمالی که در آینده پیش بیاید نیاز هست که بتوان تست نوشت و به درستی نرم‌افزار را تست کرد. همینطور هردو روش تاکید بر پوشش کد با تست‌های مختلف و توسعه حالت‌های خاص و مدیریت و بررسی کد و سادگی در نگه‌داری میباشد.
سوال چهارم: بله. البته من در پیاده سازی به اشتباه از مستطیل ارث بری کردم ولی الان که میبینم متوجه میشم که اصول Soild نقض میشوند. در نتیجه اگر در صورتی که از عدم تغییر ابعاد مستطیل مطمعن هستیم مشکلی نیست.

</div>
